package GENDB::Remote::Server::Tool;

=head1 NAME

GENDB::Remote::Server::Tool

=head1 DESCRIPTION

This package handles all interactions with a single tool on the server side.
The methods below describe the Tool interface to be implemented when extending
this class.

This is the most basic tool class, allowing only for static command lines, 
where no additional processing is required for both synchronous and 
asynchronous execution. The only wildcards supported are _INPUT_ and
_FASTA_INPUT_, which may be used as placeholders for filenames containing
the input data in raw or Fasta format.

For synchronous execution, all given parameters will be checked if an
attribute with the same name was provided by the client, and if so,
it will be replaced with the corresponding value.

=head1 CONFIGURATION

While specific information about a tool is stored in the 
L<GENDB::Remote::Server::ToolList> database, class-generic configuration is
maintained in a text-based configuration file.

The directives

 ToolDB /path/to/tool_database
 TempDirectory /temporary/directory

have to be present in order to use this package, but further class-specific
configuration data may be necessary depending on the tool used.

This package can only execute (run()) commands consisting of a single executable
and with output written to stdout. If this doesn't suit your needs, you'll have
to extend this class; see L<GENDB::Remote::Server::Tool::Blast> and 
L<GENDB::Remote::Server::Tool::HMMPfam> for examples.

See L<GENDB::Remote::Server::Configuration> for an example configuration.

=head2 Available methods

=over 4

=cut

use strict;
use warnings;

use GENDB::Remote::Server::ToolList;
use GENDB::Remote::Server::Configuration;
use FreezeThaw qw(freeze thaw);
use File::Temp;

=item * GENDB::Remote::Server::Tool B<new>(%data)

Use this method to create a new tool. The hash parameter has to contain
the keys 'tool_name', 'tool_descr', 'tool_data' and 'enabled'.

'tool_data' has to point to a hash containing either a key 'CLASS'
or both 'EXEC_CMD' and 'RUN_CMD'. If 'CLASS' exists as a key, its value
has to be the name of a class that can execute the command.
Additionally, 'tool_data' has to contain a key 'SCHED_CLASS', specifying the
scheduler class to execute the tool, and an optional key 'SCHED_OPTS', where
additional scheduler options for a tool can be defined.

The tool gets initialised and saved to the L<GENDB::Remote::Server::ToolList>,
if its configuration is sufficient.

Example:

  my %md5sum = ( tool_name => 'MD5SUM',
                 tool_descr => 'compute MD5 hash of input',
                 tool_data => { EXEC_CMD => "/usr/bin/md5sum _FASTA_INPUT_",
                                RUN_CMD => "/usr/bin/md5sum _FASTA_INPUT_",
                                SCHED_CLASS => "Scheduler::DRMAA" },
                 enabled => 1);
  my $md5sum_tool = GENDB::Remote::Server::Tool->new(%md5sum);


  RETURNS: the new object

=cut

sub new {
    my ($class, %data) = @_;
    my $self = { tool_name => delete $data{tool_name},
                 tool_descr => delete $data{tool_descr},
                 enabled => delete $data{enabled} };
    bless($self, $class);

    # save to db
    my $toollist = GENDB::Remote::Server::ToolList->new($self->_tooldb);
    $self->{tool_id} = $toollist->add($self->{tool_name}, 
                                      $self->{tool_descr},
                                      freeze($data{tool_data}),
                                      $self->{enabled});


    $self->{valid} = 1;
    return $self;
}


=item * GENDB::Remote::Server::Tool B<init>($id)

Creates a tool based on the information in the L<GENDB::Remote::Server::ToolList>.

  RETURNS: the new object

=cut

sub init {
    my ($class, $id) = @_;
    return unless (defined($id));
    my $self = $class->_initialize($id);
    return $self;
}


=item * STRING B<run>($input, %attributes)

Run the tool on the input sequence. Additional parameters may be specified
using the %attributes hash.

  RETURNS: the output generated by a tool

=cut

sub run {
    my ($self, $input, %attributes) = @_;
    $self->_check_valid();

    unless ($self->available()) {
        die __PACKAGE__.": Tool is not available.\n";
    }

    my @cmd = @{$self->prepare_run($input, %attributes)};

    unless (scalar @cmd) {
        die __PACKAGE__.": Nothing to run?\n";
    }

    my $file; 
   
    foreach (@cmd) {
        if ($_ =~ /_FASTA_INPUT_/ ) {
            $file = $self->_write_fasta_file($input, 0);
            $_ = $file->filename();
        }
        elsif ($_ =~ /_INPUT_/ ) {
            $file = $self->_write_file($input, 0);
            $_ = $file->filename();
        }
    } 

    my $out= File::Temp->new(DIR => $self->_tempdir(),
                              TEMPLATE => "in_XXXXXXXX",
                              UNLINK => 1);


    $|=1;
    my $c = join(' ', @cmd); 

    $c .= " > ".$out->filename(); # . " 2>/vol/codine-tmp/GenDB-WS/err";
    system($c);
    open(F, $out->filename());

    my $output;
    while (<F>) {
        $output .= $_;
    }
    close(F);
    return $output;

    ###################################

    my $pid = open(CHILD, "-|");

    if ($pid) {   # parent
        while (<CHILD>) {
            $output .= $_;
        }
        close(CHILD) || warn "child exited $?";
    } else {      # child
        STDOUT->autoflush(1);
        exec(@cmd) || die "can't exec program: $!";
    }
    
    return $output;
}


=item * STRING B<command_line>()

Retrieve the command line for asynchrnous execution.

=cut

sub command_line {
    my ($self) = @_;
    if ($self->available()) {
        return $self->{EXEC_CMD};
    }
}


=item * STRING B<name>()

Retrieve the name of a tool.

=cut

sub name {
    my ($self) = @_;
    return $self->{tool_name};
}


=item * INTEGER B<id>()

Retrieve the ID of a tool.

=cut

sub id {
    my ($self) = @_;
    $self->_check_valid();
    return $self->{tool_id};
}


=item * BOOL B<enable>()

Enable a tool.

  RETURNS: true, if the tool could be enabled

=cut

sub enable {
    my ($self) = @_;
    $self->_check_valid();
    $self->{enabled} = 1;
    my $toollist = GENDB::Remote::Server::ToolList->new($self->_tooldb());
    return $toollist->enable($self->{tool_id});
}


=item * BOOL B<disable>()

Disable a tool.

  RETURNS: true, if the tool could be disabled

=cut

sub disable {
    my ($self) = @_;
    $self->_check_valid();
    $self->{enabled} = 0;
    my $toollist = GENDB::Remote::Server::ToolList->new($self->_tooldb());
    return $toollist->disable($self->{tool_id});
}


=item * BOOL B<delete>()

Delete a tool from the L<GENDB::Remote::Server::ToolList>.

  RETURNS: true, if the tool was successfully deleted

=cut

sub delete {
    my ($self) = @_;
    $self->_check_valid();
    my $toollist = GENDB::Remote::Server::ToolList->new($self->_tooldb());
    my $ret = $toollist->remove($self->{tool_id});

    $self->{valid} = 0;

    return $ret;
}


=item * BOOL B<available>()

Check if a tool is configured and enabled.

=cut

sub available {
    my ($self) = @_;
    $self->_check_valid();
    return $self->{enabled} if (defined($self->{tool_id}));
    return 0;
}


sub _initialize {
    my ($class, $id) = @_;

    my $toollist = GENDB::Remote::Server::ToolList->new($class->_tooldb());
    my %tool;

    eval { %tool = %{$toollist->by_id($id)}; };
    unless (defined($tool{tool_id})) {
        die __PACKAGE__.": Tool unknown.\n";
    }

    my $self = {};
    $self->{tool_id} = $tool{tool_id};
    $self->{tool_name} = $tool{tool_name};
    $self->{tool_descr} = $tool{tool_descr};
    $self->{enabled} = $tool{enabled};
    ($self->{tool_data}) = thaw $tool{tool_data};

    unless (defined($self->{tool_data})) {
        die __PACKAGE__.": Tool configuration missing.\n";
    }

    $class = $self->{tool_data}->{CLASS} || $class;

    $self->{EXEC_CMD} = $self->{tool_data}->{EXEC_CMD};
    $self->{SCHED_CLASS} = $self->{tool_data}->{SCHED_CLASS};
    $self->{SCHED_OPTS} = $self->{tool_data}->{SCHED_OPTS};
    $self->{valid} = 1;

    eval "use $class;";
    if ($@) {
        die __PACKAGE__.": Cannot load tool class $class.\n";
    }

    bless ($self, $class);

    return $self;
}


=item * REF ON ARRAY B<prepare_run>($input, %attributes)

Builds and returns a command line based on the information contained in
%attributes and the input sequence, $input. 

The resulting command may contain the placeholders _INPUT_ and _FASTA_INPUT_
representing the names of files that contain the input sequence in 
unformatted or FASTA format. 

  RETURNS: reference on an array containing the executable and arguments
           as values

=cut

sub prepare_run {
    my ($self, $input, %attributes) = @_;

    my $cmd = $self->{tool_data}->{RUN_CMD};

    foreach (keys %attributes) {
        $cmd =~ s/$_/$attributes{$_}/g;
    }
    return split(/ /,$cmd);
}

=item * STRING B<scheduler_options>()

Returns the configured options to be used with the scheduler
for this tool as a string.

=cut

sub scheduler_options {
    my ($self) = @_;
    return $self->{SCHED_OPTS};
}


=item * STRING B<scheduler_class>()

Returns the name of the class to be used as a scheduler for this
tool.

=cut

sub scheduler_class {
    my ($self) = @_;
    return $self->{SCHED_CLASS};
}


sub _tooldb {
    my ($self) = @_;

    my $config = GENDB::Remote::Server::Configuration->new($self->_configfile());
    my $tooldb = $config->get("ToolDB");

    unless (defined($tooldb)) {
        die __PACKAGE__.": Configuration error - missing ToolDB directive.\n";
    }
    return $tooldb;
}


sub _tempdir {
    my ($self) = @_;

    return $self->{TEMPDIR} if (defined($self->{TEMPDIR}));

    my $config = GENDB::Remote::Server::Configuration->new($self->_configfile());
    $self->{TEMPDIR} = $config->get("TempDirectory");
    unless (defined($self->{TEMPDIR})) {
        die __PACKAGE__.": Configuration error - Missing TempDirectory directive.\n";
    }
    unless ((-d $self->{TEMPDIR}) && (-w $self->{TEMPDIR})) {
        die __PACKAGE__.": ".$self->{TEMPDIR}. " is not a directory or cannot be written to.\n";
    }
    return $self->{TEMPDIR};
}


sub _configfile {
    return $ENV{gendb_VAR_DIR}.'/server.config';
}


sub _check_valid {
    my ($self) = @_;
    unless ($self->{valid} == 1) {
        die __PACKAGE__.": Cannot invoke method. Maybe you forgot new()/init() or called delete()?\n";
    }
}


sub _class_config {
    my ($self) = @_;

    my $config = GENDB::Remote::Server::Configuration->new($self->_configfile());
    my $class_config;
    eval { $class_config = $config->block(Class => $self->{tool_data}->{CLASS}); };
    unless (defined($class_config)) {
        die __PACKAGE__.": Configuration error - No class named ".$self->{tool_data}->{CLASS}."\n";
    }
    return $class_config;
}


sub _write_fasta_file {
    my ($self, $input, $remove) = @_;

    my $in = File::Temp->new(DIR => $self->_tempdir(),
                              TEMPLATE => "in_XXXXXXXX",
                              UNLINK => 0);

    print $in ">Unnamed sequence data\n";
    print $in $input;
    return $in;
}


sub _write_file {
    my ($self, $input, $remove) = @_;
    my $in = File::Temp->new(DIR => $self->_tempdir(),
                              TEMPLATE => "in_XXXXXXXX",
                              UNLINK => $remove);
    print $in $input;
    return $in;
}


1;

=back

=head1 SEE ALSO

L<GENDB::Remote::Server::Configuration>

L<GENDB::Remote::Server::ToolList>

L<GENDB::Remote::Server::Tool::Blast>

L<GENDB::Remote::Server::Tool::HMMPfam>

